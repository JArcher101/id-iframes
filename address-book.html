<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Address Book</title>
    
    <!-- Google Fonts - Quicksand as fallback -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    
    <style>
        /*
        =====================================================================
        CUSTOM FONTS - Base64 Embedded with Google Fonts Fallback
        =====================================================================
        Transport Medium → for buttons and headings
        Rotis Regular → for body text
        All fonts fallback to Quicksand
        =====================================================================
        */
        
        /* Transport Medium - for buttons and headings */
        @font-face {
            font-family: 'Transport';
            font-weight: 500;
            font-style: normal;
            font-display: swap;
            src: url(data:font/truetype;charset=utf-8;base64,PLACEHOLDER_TRANSPORT_BASE64) format('truetype');
            unicode-range: U+0020-003F, U+0041-10FFFF; /* Exclude @ symbol (U+0040) - fallback to Quicksand */
        }
        
        /* Rotis Sans Serif Regular - for body text */
        @font-face {
            font-family: 'RotisRegular';
            font-weight: 300;
            font-style: normal;
            font-display: swap;
            src: url(data:font/truetype;charset=utf-8;base64,PLACEHOLDER_ROTIS_REGULAR_BASE64) format('truetype');
        }
        
        /*
        =====================================================================
        ADDRESS BOOK IFRAME - STYLE SECTION
        =====================================================================
        Manages fax address book entries with drag-and-drop reordering,
        filtering, add/delete, and undo/redo functionality.
        
        COMMUNICATION ARCHITECTURE:
        - Uses window.postMessage() API for parent-child communication
        - Parent sends: 'address-book' (initial data), 'save-data' (request to save)
        - Child sends: 'new-data' (updated entries array)
        =====================================================================
        */
        
        /* Global reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: white;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'RotisRegular', 'Quicksand', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            color: #333;
        }

        .container {
            width: 100%;
            max-width: 970px;
            margin: 0 auto;
            padding: 20px;
            box-sizing: border-box;
        }

        /* Input section at top */
        .input-section {
            background: white;
            border: 1px solid #e5e5e5;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.05);
        }

        .input-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-size: 0.9rem;
            font-weight: 400;
            color: #333;
            margin-bottom: 6px;
        }

        input[type="text"] {
            font-family: 'RotisRegular', 'Quicksand', sans-serif;
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 300;
            transition: border 0.2s, box-shadow 0.2s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #003C71;
            box-shadow: 0 0 0 2px rgba(0,60,113,0.2);
        }

        .button-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .btn {
            font-family: 'Transport', 'Quicksand', sans-serif;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #003C71;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #002b43;
        }

        .btn-primary:disabled {
            background: #ccc;
            color: #666;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #f0f0f0;
            color: #333;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #e5e5e5;
        }

        .btn-secondary:disabled {
            background: #f5f5f5;
            color: #999;
            cursor: not-allowed;
        }

        /* Action buttons (undo/redo) */
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-left: auto;
        }

        /* Cards list section */
        .cards-section {
            background: white;
            border: 1px solid #e5e5e5;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.05);
        }

        .cards-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .entry-card {
            background: #f9f9f9;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            transition: all 0.2s;
            position: relative;
        }

        .entry-card:hover {
            background: #f0f0f0;
            border-color: #003C71;
            box-shadow: 0 2px 4px rgba(0,60,113,0.1);
        }

        .entry-card.dragging {
            opacity: 0.5;
            transform: scale(0.98);
        }

        .entry-card.drag-over {
            border-top: 3px solid #003C71;
        }

        .entry-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .entry-name {
            font-weight: 600;
            color: #333;
            font-size: 0.95rem;
        }

        .entry-number {
            color: #666;
            font-size: 0.85rem;
        }

        .entry-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .drag-handle {
            color: #999;
            cursor: grab;
            font-size: 1.2rem;
            padding: 5px;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        .icon-btn {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            padding: 4px 6px;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s;
            border-radius: 4px;
        }

        .icon-btn:hover {
            color: #666;
            background: #f0f0f0;
        }

        .icon-btn.delete-icon:hover {
            color: #e02424;
            background: #ffe0e0;
        }

        .icon-btn.edit-icon:hover {
            color: #003C71;
            background: #e0e8f0;
        }

        /* Edit mode styles */
        .entry-card.editing {
            border-color: #003C71;
            background: #f8f9fa;
        }

        .entry-card.editing .entry-info {
            display: none;
        }

        .entry-edit-form {
            display: none;
            flex: 1;
            flex-direction: column;
            gap: 8px;
        }

        .entry-card.editing .entry-edit-form {
            display: flex;
        }

        .entry-edit-input {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9rem;
            font-family: inherit;
        }

        .entry-edit-input:focus {
            outline: none;
            border-color: #003C71;
        }

        .entry-edit-actions {
            display: flex;
            gap: 6px;
            margin-top: 4px;
        }

        .confirm-btn {
            background: #003C71;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 12px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: background 0.2s;
        }

        .confirm-btn:hover {
            background: #002a52;
        }

        .confirm-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* New card preview (shown when no matches) */
        .new-card-preview {
            background: #fff3cd;
            border: 2px dashed #D4A574;
            border-radius: 8px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }

        .new-card-preview-label {
            font-size: 0.8rem;
            color: #856404;
            font-weight: 600;
            text-transform: uppercase;
        }

        .new-card-preview-content {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .new-card-preview-name {
            font-weight: 600;
            color: #333;
            font-size: 0.95rem;
        }

        .new-card-preview-number {
            color: #666;
            font-size: 0.85rem;
        }

        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #999;
            font-size: 0.9rem;
        }

        /* Loading state */
        .loading-state {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            text-align: center;
            color: #666;
        }

        .spinner {
            width: 30px;
            height: 30px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #003C71;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Input Section -->
        <div class="input-section">
            <div class="input-row">
                <div class="input-group">
                    <label for="nameInput">Name</label>
                    <input type="text" id="nameInput" placeholder="Enter name">
                </div>
                <div class="input-group">
                    <label for="numberInput">Fax Number</label>
                    <input type="text" id="numberInput" placeholder="Enter fax number">
                </div>
            </div>
            <div class="button-row">
                <button class="btn btn-primary" id="addBtn" disabled>Add</button>
                <button class="btn btn-primary" id="saveBtn" disabled>Save</button>
                <div class="action-buttons">
                    <button class="btn btn-secondary" id="undoBtn" disabled>Undo</button>
                    <button class="btn btn-secondary" id="redoBtn" disabled>Redo</button>
                </div>
            </div>
        </div>

        <!-- Cards Section -->
        <div class="cards-section">
            <div id="loadingState" class="loading-state">
                <div>
                    <div class="spinner"></div>
                    <div>Loading address book...</div>
                </div>
            </div>
            <div id="cardsList" class="cards-list" style="display: none;">
                <!-- Cards will be added here dynamically -->
            </div>
            <div id="emptyState" class="empty-state" style="display: none;">
                No entries found. Add a new entry above.
            </div>
        </div>
    </div>

    <script>
        /*
        =====================================================================
        ADDRESS BOOK IFRAME - JAVASCRIPT SECTION
        =====================================================================
        
        GLOBAL STATE VARIABLES:
        - entries: Complete array of address book entries
        - filteredEntries: Currently displayed entries (after filtering)
        - history: Array of state snapshots for undo/redo
        - historyIndex: Current position in history
        - draggedElement: Currently dragged card element
        - dragOverElement: Element being dragged over
        
        PARENT-CHILD COMMUNICATION:
        This iframe uses window.postMessage() to communicate with parent window.
        
        INCOMING MESSAGES (from parent):
        1. 'address-book' - Initial address book data with entries array
        2. 'save-data' - Request to save current state (returns 'new-data')
        
        OUTGOING MESSAGES (to parent):
        1. 'new-data' - Updated entries array (sent in response to 'save-data')
        =====================================================================
        */

        // Global state
        let entries = [];
        let filteredEntries = [];
        let history = [];
        let historyIndex = -1;
        let draggedElement = null;
        let dragOverElement = null;
        let dataLoaded = false;
        let editingEntryId = null; // Track which entry is being edited

        // DOM elements
        const nameInput = document.getElementById('nameInput');
        const numberInput = document.getElementById('numberInput');
        const addBtn = document.getElementById('addBtn');
        const saveBtn = document.getElementById('saveBtn');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const cardsList = document.getElementById('cardsList');
        const loadingState = document.getElementById('loadingState');
        const emptyState = document.getElementById('emptyState');

        // Initialize
        function init() {
            // Load from localStorage if available
            const saved = localStorage.getItem('addressBookEntries');
            if (saved) {
                try {
                    entries = JSON.parse(saved);
                    saveToHistory();
                    renderCards();
                } catch (e) {
                    console.error('Error loading from localStorage:', e);
                }
            }

            // Event listeners
            nameInput.addEventListener('input', handleInputChange);
            numberInput.addEventListener('input', handleInputChange);
            addBtn.addEventListener('click', handleAdd);
            saveBtn.addEventListener('click', handleSave);
            undoBtn.addEventListener('click', handleUndo);
            redoBtn.addEventListener('click', handleRedo);

            // Enter key to add
            nameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !addBtn.disabled) {
                    handleAdd();
                }
            });
            numberInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !addBtn.disabled) {
                    handleAdd();
                }
            });
        }

        // Check if entry already exists
        function entryExists(name, number) {
            return entries.some(e => 
                e.label.toLowerCase() === name.toLowerCase() && 
                e.value === number
            );
        }

        // Handle input changes (filtering and add button state)
        function handleInputChange() {
            const name = nameInput.value.trim();
            const number = numberInput.value.trim();

            // Enable add button only if both inputs are filled AND entry doesn't already exist
            const bothFilled = name && number;
            const exists = bothFilled && entryExists(name, number);
            addBtn.disabled = !bothFilled || exists;

            // Filter and render cards
            filterAndRender();
        }

        // Filter entries based on input and render
        function filterAndRender() {
            const nameFilter = nameInput.value.trim().toLowerCase();
            const numberFilter = numberInput.value.trim().toLowerCase();

            if (!nameFilter && !numberFilter) {
                // No filter - show all entries
                filteredEntries = [...entries];
            } else {
                // Filter entries based on what's typed
                filteredEntries = entries.filter(entry => {
                    const nameMatch = !nameFilter || entry.label.toLowerCase().includes(nameFilter);
                    const numberMatch = !numberFilter || entry.value.toLowerCase().includes(numberFilter);
                    // Show entry if it matches all non-empty filters (AND logic)
                    return nameMatch && numberMatch;
                });
            }

            renderCards();
        }

        // Render cards
        function renderCards() {
            // Hide loading state
            loadingState.style.display = 'none';

            // Clear existing cards
            cardsList.innerHTML = '';

            if (filteredEntries.length === 0) {
                // Show hint card to add new entry
                const name = nameInput.value.trim();
                const number = numberInput.value.trim();
                const bothFilled = name && number;
                const exists = bothFilled && entryExists(name, number);

                const hintCard = document.createElement('div');
                hintCard.className = 'new-card-preview';
                if (exists) {
                    // Entry already exists - show warning style
                    hintCard.style.background = '#f8d7da';
                    hintCard.style.borderColor = '#dc3545';
                }
                hintCard.innerHTML = `
                    <div class="new-card-preview-label" style="${exists ? 'color: #721c24;' : ''}">
                        ${exists ? 'Entry Already Exists' : bothFilled ? 'New Entry - Click Add to save' : 'No matches found'}
                    </div>
                    <div class="new-card-preview-content">
                        ${bothFilled ? `
                            <div class="new-card-preview-name">${escapeHtml(name)}</div>
                            <div class="new-card-preview-number">${escapeHtml(number)}</div>
                            ${exists ? '<div style="color: #721c24; font-size: 0.85rem; margin-top: 8px;">This entry already exists in the address book.</div>' : ''}
                        ` : `
                            <div style="color: #666; font-size: 0.9rem; line-height: 1.5;">
                                Enter both <strong>name</strong> and <strong>number</strong> above to enable the Add button and create a new entry.
                            </div>
                        `}
                    </div>
                `;
                cardsList.appendChild(hintCard);
                cardsList.style.display = 'block';
                emptyState.style.display = 'none';
            } else {
                // Render filtered entries
                filteredEntries.forEach((entry, index) => {
                    const card = createCard(entry, index);
                    cardsList.appendChild(card);
                });
                cardsList.style.display = 'block';
                emptyState.style.display = 'none';
            }
        }

        // Create a card element
        function createCard(entry, index) {
            const card = document.createElement('div');
            const entryId = entry.label + entry.value;
            const isEditing = editingEntryId === entryId;
            
            card.className = isEditing ? 'entry-card editing' : 'entry-card';
            card.draggable = !isEditing; // Disable drag when editing
            card.dataset.index = index;
            card.dataset.entryId = entryId;
            card.dataset.entryLabel = entry.label;
            card.dataset.entryValue = entry.value;

            card.innerHTML = `
                <div class="entry-info">
                    <div class="entry-name">${escapeHtml(entry.label)}</div>
                    <div class="entry-number">${escapeHtml(entry.value)}</div>
                </div>
                <div class="entry-edit-form">
                    <input type="text" class="entry-edit-input edit-name-input" value="${escapeHtml(entry.label)}" placeholder="Name">
                    <input type="text" class="entry-edit-input edit-number-input" value="${escapeHtml(entry.value)}" placeholder="Number">
                    <div class="entry-edit-actions">
                        <button class="confirm-btn">Confirm</button>
                        <button class="icon-btn cancel-edit-btn" style="padding: 4px 8px; font-size: 0.85rem;">Cancel</button>
                    </div>
                </div>
                <div class="entry-actions">
                    <span class="drag-handle">☰</span>
                    <button class="icon-btn edit-icon" title="Edit">✏️</button>
                    <button class="icon-btn delete-icon" title="Delete">✕</button>
                </div>
            `;

            // Drag and drop handlers (only if not editing)
            if (!isEditing) {
                card.addEventListener('dragstart', handleDragStart);
                card.addEventListener('dragend', handleDragEnd);
                card.addEventListener('dragover', handleDragOver);
                card.addEventListener('drop', handleDrop);
                card.addEventListener('dragleave', handleDragLeave);
            }

            // Edit button
            const editBtn = card.querySelector('.edit-icon');
            editBtn.addEventListener('click', () => handleEdit(entryId));

            // Delete button
            const deleteBtn = card.querySelector('.delete-icon');
            deleteBtn.addEventListener('click', () => {
                handleDelete(entry.label, entry.value);
            });

            // Enter key to confirm edit and validation
            if (isEditing) {
                const nameInput = card.querySelector('.edit-name-input');
                const numberInput = card.querySelector('.edit-number-input');
                const confirmBtn = card.querySelector('.confirm-btn');
                const cancelBtn = card.querySelector('.cancel-edit-btn');
                
                const checkCanConfirm = () => {
                    const name = nameInput.value.trim();
                    const number = numberInput.value.trim();
                    // Check if entry exists, but exclude the current entry being edited
                    const originalEntry = entries.find(e => (e.label + e.value) === entryId);
                    const exists = entries.some(e => 
                        e !== originalEntry &&
                        e.label.toLowerCase() === name.toLowerCase() && 
                        e.value === number
                    );
                    confirmBtn.disabled = !name || !number || exists;
                };
                
                nameInput.addEventListener('input', checkCanConfirm);
                numberInput.addEventListener('input', checkCanConfirm);
                checkCanConfirm(); // Initial check
                
                nameInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !confirmBtn.disabled) {
                        handleConfirmEdit(entryId);
                    }
                });
                numberInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !confirmBtn.disabled) {
                        handleConfirmEdit(entryId);
                    }
                });
                
                confirmBtn.addEventListener('click', () => handleConfirmEdit(entryId));
                cancelBtn.addEventListener('click', handleCancelEdit);
            }

            return card;
        }

        // Drag and drop handlers
        function handleDragStart(e) {
            draggedElement = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');
            // Remove drag-over class from all cards
            document.querySelectorAll('.entry-card').forEach(card => {
                card.classList.remove('drag-over');
            });
            draggedElement = null;
            dragOverElement = null;
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';

            if (this !== draggedElement) {
                this.classList.add('drag-over');
                dragOverElement = this;
            }
            return false;
        }

        function handleDragLeave(e) {
            this.classList.remove('drag-over');
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }

            if (draggedElement !== this) {
                const draggedIndex = parseInt(draggedElement.dataset.index);
                const dropIndex = parseInt(this.dataset.index);

                // Get the dragged entry
                const draggedEntry = filteredEntries[draggedIndex];

                // Find indices in original entries array
                const draggedOriginalIndex = entries.findIndex(e => 
                    e.label === draggedEntry.label && e.value === draggedEntry.value
                );

                // Get the entry at drop position in filtered list
                const dropEntry = filteredEntries[dropIndex];
                const dropOriginalIndex = entries.findIndex(e => 
                    e.label === dropEntry.label && e.value === dropEntry.value
                );

                // Reorder in original entries array
                if (draggedOriginalIndex !== -1 && dropOriginalIndex !== -1) {
                    const [movedEntry] = entries.splice(draggedOriginalIndex, 1);
                    entries.splice(dropOriginalIndex, 0, movedEntry);
                }

                // Reorder in filtered entries array
                filteredEntries.splice(draggedIndex, 1);
                filteredEntries.splice(dropIndex, 0, draggedEntry);

                // Save to history and localStorage
                saveToHistory();
                saveToLocalStorage();

                // Re-render
                renderCards();
            }

            this.classList.remove('drag-over');
            return false;
        }

        // Handle add button click
        function handleAdd() {
            const name = nameInput.value.trim();
            const number = numberInput.value.trim();

            if (!name || !number) {
                return;
            }

            // Check if entry already exists (shouldn't happen if button is disabled, but double-check)
            if (entryExists(name, number)) {
                return;
            }

            // Add new entry
            const newEntry = { label: name, value: number };
            entries.push(newEntry);

            // Save to history and localStorage
            saveToHistory();
            saveToLocalStorage();

            // Clear inputs
            nameInput.value = '';
            numberInput.value = '';
            addBtn.disabled = true;

            // Re-render
            filterAndRender();
        }

        // Handle delete
        function handleDelete(label, value) {
            if (confirm(`Delete "${label}"?`)) {
                entries = entries.filter(e => !(e.label === label && e.value === value));
                
                // Clear edit mode if deleting the entry being edited
                const entryId = label + value;
                if (editingEntryId === entryId) {
                    editingEntryId = null;
                }
                
                // Save to history and localStorage
                saveToHistory();
                saveToLocalStorage();

                // Re-render
                filterAndRender();
            }
        }

        function handleEdit(entryId) {
            // Exit any other edit mode
            editingEntryId = entryId;
            filterAndRender();
        }

        function handleCancelEdit() {
            editingEntryId = null;
            filterAndRender();
        }

        function handleConfirmEdit(entryId) {
            const card = document.querySelector(`[data-entry-id="${entryId}"]`);
            if (!card) return;

            const nameInput = card.querySelector('.edit-name-input');
            const numberInput = card.querySelector('.edit-number-input');
            
            const newName = nameInput.value.trim();
            const newNumber = numberInput.value.trim();

            if (!newName || !newNumber) {
                return;
            }

            // Find the original entry
            const originalEntry = entries.find(e => (e.label + e.value) === entryId);
            if (!originalEntry) return;

            // Check if the new entry already exists (excluding the current entry)
            const exists = entries.some(e => 
                e !== originalEntry &&
                e.label.toLowerCase() === newName.toLowerCase() && 
                e.value === newNumber
            );

            if (exists) {
                alert('This entry already exists.');
                return;
            }

            // Update the entry
            originalEntry.label = newName;
            originalEntry.value = newNumber;

            // Exit edit mode
            editingEntryId = null;

            // Save to history and localStorage
            saveToHistory();
            saveToLocalStorage();

            // Re-render
            filterAndRender();
        }

        // Handle save button click
        function handleSave() {
            sendDataToParent();
        }

        // Send data to parent
        function sendDataToParent() {
            // Disable save button while sending
            saveBtn.disabled = true;
            
            window.parent.postMessage({
                type: 'new-data',
                entries: entries
            }, '*');
        }

        // Undo/Redo functionality
        function saveToHistory() {
            // Remove any history after current index
            history = history.slice(0, historyIndex + 1);
            
            // Add current state
            history.push(JSON.parse(JSON.stringify(entries)));
            historyIndex++;

            // Limit history size (keep last 50 states)
            if (history.length > 50) {
                history.shift();
                historyIndex--;
            }

            updateUndoRedoButtons();
        }

        function handleUndo() {
            if (historyIndex > 0) {
                historyIndex--;
                entries = JSON.parse(JSON.stringify(history[historyIndex]));
                saveToLocalStorage();
                filterAndRender();
                updateUndoRedoButtons();
            }
        }

        function handleRedo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                entries = JSON.parse(JSON.stringify(history[historyIndex]));
                saveToLocalStorage();
                filterAndRender();
                updateUndoRedoButtons();
            }
        }

        function updateUndoRedoButtons() {
            undoBtn.disabled = historyIndex <= 0;
            redoBtn.disabled = historyIndex >= history.length - 1;
        }

        // Local storage
        function saveToLocalStorage() {
            try {
                localStorage.setItem('addressBookEntries', JSON.stringify(entries));
            } catch (e) {
                console.error('Error saving to localStorage:', e);
            }
        }

        // Utility function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // PostMessage listener
        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'address-book') {
                // Hide loading state
                loadingState.style.display = 'none';

                // Load entries from parent
                if (event.data.data && Array.isArray(event.data.data.entries)) {
                    entries = event.data.data.entries.map(e => ({
                        label: e.label || '',
                        value: e.value || ''
                    }));
                    
                    // Mark data as loaded
                    dataLoaded = true;
                    
                    // Save to history and localStorage
                    saveToHistory();
                    saveToLocalStorage();
                    
                    // Enable save button
                    saveBtn.disabled = false;
                    
                    // Render
                    filterAndRender();
                }
            } else if (event.data && event.data.type === 'save-data') {
                // Send updated entries back to parent (legacy support)
                sendDataToParent();
            } else if (event.data && event.data.type === 'upload-success') {
                // Re-enable save button after successful upload
                if (entries.length > 0 && dataLoaded) {
                    saveBtn.disabled = false;
                }
            } else if (event.data && event.data.type === 'upload-error') {
                // Re-enable save button after upload error
                if (entries.length > 0 && dataLoaded) {
                    saveBtn.disabled = false;
                }
            }
        });

        // Initialize on load
        init();
    </script>
<!-- IFRAME_VERSION START -->
<script>
  (function() {
    window.__IFRAME_VERSION__ = '5c2bfd8';
    console.log('[address-book] version ' + window.__IFRAME_VERSION__);
  })();
</script>
<!-- IFRAME_VERSION END -->
</body>
</html>

